import { EventEmitter } from 'node:events';
import { randomBytes } from 'node:crypto';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import WebSocket from 'ws';
import { EphemeralKey } from '../crypto/p256.js';
import { RC4 } from '../crypto/rc4.js';
import { DagCborDecoder } from '../cbor/dagCborDecoder.js';
import { encodeDagCbor } from '../cbor/dagCborEncoder.js';

const DEVICE_ID_LENGTH = 21;
const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Mobile Safari/537.36';

const STATUS_SUCCESS = 0;

const OPCODES = {
  POLL: 0x1,
  ASSIGN_ACCOUNT: 0x4,
  HEARTBEAT: 0x5,
  USER_INFO: 0x7,
  EVENTS: 0xb,
  HISTORY: 0x17,
};

const UPDATE_KIND_BY_OPCODE = {
  0x3: 'odds',
  0x4: 'live',
  0x6: 'matches',
};

export class XbetClient extends EventEmitter {
  constructor(options) {
    super();
    this.endpoint = options.endpoint;
    this.auth = {
      token: options.token,
      username: options.username,
      password: options.password,
      email: options.email,
      code: options.code
    };
    this.origin = options.origin || '';
    this.wsHeaders = { ...(options.wsHeaders || {}) };
    this.userAgent = options.userAgent || this.wsHeaders['user-agent'] || DEFAULT_USER_AGENT;
    if (!this.wsHeaders['user-agent'] && this.userAgent) {
      this.wsHeaders['user-agent'] = this.userAgent;
    }
    this.ws = null;
    this.ephemeral = null;
    this.rc4 = null;
    this.deviceId = options.deviceId || null;
    const resolvedDeviceIdFile = options.deviceIdFile === null || options.deviceIdFile === false
      ? null
      : path.resolve(options.deviceIdFile || '.xbet-device-id');
    this.deviceIdFile = resolvedDeviceIdFile;
    this.deviceIdPromise = null;

    // æ–°åè®®ï¼šRPC è¯·æ±‚ç®¡ç†
    this.reqs = new Map();  // å­˜å‚¨å¾…å“åº”çš„è¯·æ±‚: reqId -> [reqId, opcode, payload, resolve, timer, sent]
    this.reqId = 0;         // è‡ªå¢è¯·æ±‚ ID
    this.defaultTimeout = options.timeout || 20000;  // é»˜è®¤ 20 ç§’è¶…æ—¶
    this.cursor = 0;        // è½®è¯¢æ¸¸æ ‡
    this.polling = false;
    this.pollIntervalMs = options.pollIntervalMs ?? 1000;
    this.session = null;

    // ä¿ç•™æ—§çš„è®¢é˜…å’Œå¿ƒè·³é…ç½®ï¼ˆå¯èƒ½åœ¨æ–°åè®®ä¸­ä¸å†ä½¿ç”¨ï¼‰
    this.subscriptions = [...new Set(options.subscriptions || [])];
    this.heartbeatIntervalMs = options.heartbeatIntervalMs || 30_000;
    this.heartbeatTimer = null;
    this.authenticated = false;
  }

  async connect() {
    if (this.ws) {
      this.ws.close();
    }
    this.ephemeral = await new EphemeralKey().generate();
    const headers = Object.fromEntries(
      Object.entries(this.wsHeaders).filter(([, value]) => typeof value === 'string' && value.length)
    );
    const wsOptions = {
      perMessageDeflate: true,
      handshakeTimeout: 10000,
    };
    if (this.origin) {
      wsOptions.origin = this.origin;
    }
    if (Object.keys(headers).length) {
      wsOptions.headers = headers;
    }
    const url = this.#buildEndpointUrl();
    this.ws = new WebSocket(url, wsOptions);
    this.ws.binaryType = 'arraybuffer';
    this.ws.on('open', () => this.#handleOpen());
    this.ws.on('error', (err) => this.emit('error', err));
    this.ws.on('close', (code, reason) => {
      const closeEvent = { code, reason: this.#decodeReason(reason) };
      this.#handleClose(closeEvent);
      this.emit('close', closeEvent);
    });
    this.ws.on('message', (data) => this.#handleRawMessage(data));
  }

  #handleOpen() {
    const frame = this.ephemeral.buildClientHelloFrame();
    this.ws.send(frame);
    this.emit('handshakeSent');
  }

  #decodeReason(reason) {
    if (!reason) return '';
    if (typeof reason === 'string') return reason;
    if (reason instanceof ArrayBuffer) {
      return Buffer.from(reason).toString('utf-8');
    }
    if (ArrayBuffer.isView(reason)) {
      return Buffer.from(reason.buffer, reason.byteOffset, reason.byteLength).toString('utf-8');
    }
    if (Buffer.isBuffer(reason)) {
      return reason.toString('utf-8');
    }
    return String(reason);
  }

  async #handleRawMessage(data) {
    const payload = this.#toUint8Array(data);
    if (!this.rc4) {
      await this.#handleServerHandshake(payload);
      return;
    }
    console.log('ğŸ“¥ æ”¶åˆ°æ¶ˆæ¯:', payload.length, 'å­—èŠ‚');

    const decrypted = this.rc4.process(payload);
    console.log('  è§£å¯†å (hex):', Buffer.from(decrypted).toString('hex'));

    try {
      const decoder = new DagCborDecoder(decrypted);
      const message = decoder.decode();
      console.log('  è§£ç å:', JSON.stringify(message));

      this.#handleDecodedMessage(message);
    } catch (err) {
      console.log('  âŒ è§£ç å¤±è´¥:', err.message);
      this.emit('decodeError', { err, raw: decrypted });
    }
  }

  async #handleServerHandshake(data) {
    if (data.length < 65) {
      throw new Error('æœåŠ¡å™¨æ¡æ‰‹æ•°æ®å¼‚å¸¸');
    }
    console.log('ğŸ¤ å¤„ç†æœåŠ¡å™¨æ¡æ‰‹...');
    console.log('  æœåŠ¡å™¨æ¡æ‰‹æ•°æ®é•¿åº¦:', data.length);

    const serverKey = data.slice(0, 65);
    console.log('  æœåŠ¡å™¨å…¬é’¥ (å‰10å­—èŠ‚):', Buffer.from(serverKey.slice(0, 10)).toString('hex'));

    const sharedSecret = await this.ephemeral.deriveSharedSecret(serverKey);
    console.log('  å…±äº«å¯†é’¥ (å‰10å­—èŠ‚):', Buffer.from(sharedSecret.slice(0, 10)).toString('hex'));

    this.rc4 = new RC4(sharedSecret);
    this.#flushPendingRequests();
    this.emit('sessionReady');

    const rest = data.slice(65);
    console.log('  æ¡æ‰‹åå‰©ä½™æ•°æ®é•¿åº¦:', rest.length);

    if (rest.length) {
      try {
        const decrypted = this.rc4.process(rest);
        console.log('  è§£å¯†åæ•°æ® (hex):', Buffer.from(decrypted).toString('hex'));

        const decoder = new DagCborDecoder(decrypted);
        const message = decoder.decode();
        console.log('  è§£ç åæ¶ˆæ¯:', JSON.stringify(message));

        this.#handleDecodedMessage(message);
      } catch (err) {
        console.log('  âŒ è§£ç å¤±è´¥:', err.message);
        this.emit('decodeError', { err, raw: rest });
      }
    }

    // ğŸ¯ æµ‹è¯•ï¼šåœ¨è®¤è¯ä¹‹å‰å‘é€åˆå§‹åŒ–æ¶ˆæ¯
    if (this.initMessages && this.initMessages.length > 0) {
      console.log('ğŸ” å‘é€åˆå§‹åŒ–æ¶ˆæ¯:', this.initMessages.length, 'æ¡');
      for (const [opcode, payload] of this.initMessages) {
        const message = [this.reqId++, opcode, payload];
        const encoded = encodeDagCbor(message);
        const encrypted = this.rc4.process(encoded);
        console.log(`  å‘é€: opcode=0x${opcode.toString(16)}, ${encoded.length} å­—èŠ‚`);
        this.ws.send(encrypted);
      }
    }

    await this.#authenticate();
  }

  #toUint8Array(data) {
    if (!data) {
      return new Uint8Array();
    }
    if (data instanceof Uint8Array) {
      return data;
    }
    if (data instanceof ArrayBuffer) {
      return new Uint8Array(data);
    }
    if (ArrayBuffer.isView(data)) {
      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    }
    if (typeof data === 'string') {
      return new TextEncoder().encode(data);
    }
    return new Uint8Array(data);
  }

  async #authenticate() {
    try {
      console.log('ğŸ” å‘é€ç™»å½•è¯·æ±‚ (opcode 0x4)...');
      const loginPayload = await this.#buildLoginPayload();
      console.log('ğŸ“¤ ç™»å½• payload:', JSON.stringify(loginPayload, null, 2));

      const [status, data] = await this.request(OPCODES.ASSIGN_ACCOUNT, loginPayload);
      console.log('âœ… ç™»å½•å“åº”æ”¶åˆ°:', { status, data });

      if (status !== STATUS_SUCCESS) {
        throw new Error(`ç™»å½•å¤±è´¥: ${data}`);
      }

      this.session = data;
      this.authenticated = true;

      // ç™»å½•æˆåŠŸåï¼Œå¯é€‰ï¼šè·å–ç”¨æˆ·ä¿¡æ¯
      console.log('ğŸ” è·å–ç”¨æˆ·ä¿¡æ¯ (opcode 0x7)...');
      try {
        const [s, userInfo] = await this.request(OPCODES.USER_INFO, {});
        if (s === STATUS_SUCCESS) {
          console.log('  âœ… ç”¨æˆ·ä¿¡æ¯:', userInfo);
          this.session = { ...this.session, ...userInfo };
        }
      } catch (err) {
        console.log('  âš ï¸  è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥ (å¯å¿½ç•¥):', err.message);
      }

      this.emit('authenticated', data || { code: 0 });
      await this.#prefetchInitialData();
      this.startHeartbeat();
      this.#startPolling();
    } catch (err) {
      this.emit('error', err);
      this.stop();
    }
  }

  /**
   * æ–°åè®®ï¼šRPC è¯·æ±‚æ–¹æ³•
   * @param {number} opcode - æ“ä½œç  (0x1, 0x5, 0x7, 0xb, 0x17 ç­‰)
   * @param {object} payload - è¯·æ±‚å‚æ•°
   * @param {number} timeout - è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰ï¼Œ0 è¡¨ç¤ºä¸è¶…æ—¶
   * @returns {Promise<[number, any]>} - [status, data]ï¼Œstatus: 0=æˆåŠŸ, 1=å¤±è´¥
   */
  async request(opcode, payload = {}, timeout = this.defaultTimeout) {
    return new Promise((resolve) => {
      const reqId = ++this.reqId & 0xffffffff;  // 32 ä½å¾ªç¯

      let timer = null;
      if (timeout > 0) {
        timer = setTimeout(() => {
          this.reqs.delete(reqId);
          resolve([1, 'err_timeout']);
        }, timeout);
      }

      // å­˜å‚¨è¯·æ±‚ä¸Šä¸‹æ–‡: [reqId, opcode, payload, resolve, timer, sent]
      const req = [reqId, opcode, payload, resolve, timer, false];
      this.reqs.set(reqId, req);

      // å¦‚æœ RC4 å·²å°±ç»ªï¼Œç«‹å³å‘é€
      if (this.rc4 && this.ws && this.ws.readyState === WebSocket.OPEN) {
        this.#sendRequest(req);
      }
    });
  }

  /**
   * å‘é€ RPC è¯·æ±‚
   * @private
   */
  #sendRequest(req) {
    const [reqId, opcode, payload] = req;

    // æ–°åè®®æ¶ˆæ¯æ ¼å¼: [reqId, opcode, payload]
    const message = [reqId, opcode, payload];

    try {
      const encoded = encodeDagCbor(message);
      const encrypted = this.rc4.process(encoded);

      console.log(`ğŸ“¤ å‘é€è¯·æ±‚: reqId=${reqId}, opcode=0x${opcode.toString(16)}, payload=`, JSON.stringify(payload));
      console.log(`  ç¼–ç å: ${encoded.length} å­—èŠ‚, åŠ å¯†å: ${encrypted.length} å­—èŠ‚`);
      console.log(`  ç¼–ç å†…å®¹ (hex):`, Buffer.from(encoded).toString('hex'));

      this.ws.send(encrypted);
      req[5] = true;  // æ ‡è®°ä¸ºå·²å‘é€

      this.emit('requestSent', { reqId, opcode, payload });
    } catch (err) {
      // å‘é€å¤±è´¥ï¼Œæ¸…ç†è¯·æ±‚
      const [, , , resolve, timer] = req;
      if (timer) clearTimeout(timer);
      this.reqs.delete(reqId);
      resolve([1, err.message]);
    }
  }

  #flushPendingRequests() {
    if (!this.rc4 || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
      return;
    }
    for (const req of this.reqs.values()) {
      if (!req[5]) {
        this.#sendRequest(req);
      }
    }
  }

  #resolveRequest(reqId, status, payload) {
    const req = this.reqs.get(reqId);
    if (!req) {
      this.emit('unmatchedResponse', { reqId, status, payload });
      return;
    }
    const [, opcode, , resolve, timer] = req;
    if (timer) clearTimeout(timer);
    this.reqs.delete(reqId);
    resolve([status, this.#normalizePayload(payload)]);
    this.emit('response', { reqId, opcode, status });
  }

  #rejectAllRequests(reason = 'err_closed') {
    for (const [reqId, req] of this.reqs.entries()) {
      const [, , , resolve, timer] = req;
      if (timer) clearTimeout(timer);
      resolve([1, reason]);
      this.emit('response', { reqId, status: 1, reason });
    }
    this.reqs.clear();
  }

  /**
   * æ—§åè®®å…¼å®¹ï¼šç›´æ¥å‘é€å¯¹è±¡ï¼ˆå·²åºŸå¼ƒï¼Œå»ºè®®ä½¿ç”¨ requestï¼‰
   * @deprecated
   */
  async send(obj) {
    if (!this.rc4) {
      throw new Error('RC4 å°šæœªåˆå§‹åŒ–');
    }
    const encoded = encodeDagCbor(obj);
    const encrypted = this.rc4.process(encoded);
    this.ws.send(encrypted);
  }

  /**
   * æ—§åè®®å…¼å®¹ï¼šè®¢é˜…ï¼ˆæ–°åè®®å¯èƒ½ä¸å†ä½¿ç”¨ï¼‰
   * @deprecated
   */
  async subscribe(subscriptions = this.subscriptions) {
    const unique = [...new Set(subscriptions)].filter(Boolean);
    this.subscriptions = unique;
    if (!unique.length) return;
    // æ—§åè®®: { typ: 1, data: [...] }
    // æ–°åè®®å¯èƒ½éœ€è¦æ”¹ä¸º request(OPCODE_SUBSCRIBE, { topics: [...] })
    await this.send({ typ: 1, data: unique });
  }

  /**
   * å¯åŠ¨å¿ƒè·³ï¼ˆæ–°åè®®ä½¿ç”¨ opcode 0x5ï¼‰
   */
  startHeartbeat() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
    }
    if (this.heartbeatIntervalMs <= 0) return;

    this.heartbeatTimer = setInterval(() => {
      // æ–°åè®®ï¼šä½¿ç”¨ opcode 0x5 å‘é€å¿ƒè·³
      this.request(0x5, {}, 5000).catch((err) => {
        this.emit('error', err);
      });
    }, this.heartbeatIntervalMs);
  }

  stop() {
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
    this.polling = false;
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }

  async #call(opcode, payload = {}, timeout) {
    const [status, raw] = await this.request(opcode, payload, timeout);
    const data = this.#normalizePayload(raw);
    if (status !== STATUS_SUCCESS) {
      const reason = typeof data === 'string' ? data : JSON.stringify(data);
      throw new Error(`Opcode 0x${opcode.toString(16)} failed: ${reason}`);
    }
    return data;
  }

  #normalizePayload(payload) {
    if (typeof payload === 'string') {
      try {
        return JSON.parse(payload);
      } catch {
        return payload;
      }
    }
    return payload;
  }

  async #ensureDeviceId() {
    if (!this.deviceIdPromise) {
      this.deviceIdPromise = this.#loadDeviceId().catch((err) => {
        this.deviceIdPromise = null;
        throw err;
      });
    }
    return this.deviceIdPromise;
  }

  async #loadDeviceId() {
    if (this.deviceId && this.#isValidDeviceId(this.deviceId)) {
      return this.deviceId;
    }
    if (this.deviceIdFile) {
      try {
        const stored = (await fs.readFile(this.deviceIdFile, 'utf-8')).trim();
        if (this.#isValidDeviceId(stored)) {
          this.deviceId = stored;
          return stored;
        }
      } catch (err) {
        if (err.code !== 'ENOENT') {
          this.emit('warn', `è¯»å– deviceId å¤±è´¥: ${err.message}`);
        }
      }
    }
    const generated = this.#generateDeviceId();
    if (this.deviceIdFile) {
      try {
        await fs.writeFile(this.deviceIdFile, generated, 'utf-8');
      } catch (err) {
        this.emit('warn', `ä¿å­˜ deviceId å¤±è´¥: ${err.message}`);
      }
    }
    this.deviceId = generated;
    return generated;
  }

  #generateDeviceId() {
    const alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789';
    let output = '';
    while (output.length < DEVICE_ID_LENGTH) {
      const bytes = randomBytes(DEVICE_ID_LENGTH);
      for (const byte of bytes) {
        if (output.length >= DEVICE_ID_LENGTH) break;
        output += alphabet[byte % alphabet.length];
      }
    }
    return output;
  }

  #isValidDeviceId(value) {
    return typeof value === 'string' && value.length === DEVICE_ID_LENGTH && /^[a-z0-9]+$/i.test(value);
  }

  async #buildLoginPayload() {
    const did = await this.#ensureDeviceId();
    const payload = {
      did,
      ua: this.userAgent || DEFAULT_USER_AGENT
    };

    // XBet ç½‘é¡µç«¯ç™»å½•æ—¶ï¼Œusr/pwd/email ä½äºé¡¶å±‚ï¼›åªæœ‰â€œåˆ†é…è´¦å·â€æµç¨‹æ‰ä¼šåœ¨ ext ä¸­å¸¦å­è´¦å·ã€‚
    if (this.auth.username) {
      payload.usr = this.auth.username;
    }
    if (this.auth.password) {
      payload.pwd = this.auth.password;
    }
    if (this.auth.email) {
      payload.email = this.auth.email;
    }
    if (this.auth.code) {
      payload.code = this.auth.code;
    }

    // é¢„ç•™æ‰©å±•å­—æ®µï¼ˆä¾‹å¦‚ assignAccount æµç¨‹éœ€è¦çš„å­è´¦å·ä¿¡æ¯ï¼‰
    if (this.auth.ext && Object.keys(this.auth.ext).length) {
      payload.ext = { ...this.auth.ext };
    }

    return payload;
  }

  async #prefetchInitialData() {
    try {
      const matches = await this.#call(OPCODES.EVENTS, {});
      this.#ingestDataset('matches', matches);
    } catch (err) {
      this.emit('warn', `Prefetch events failed: ${err.message}`);
    }
  }

  #ingestDataset(kind, payload) {
    if (!payload) return;
    if (Array.isArray(payload)) {
      for (const item of payload) {
        this.#emitData(kind, item);
      }
      return;
    }
    if (typeof payload === 'object') {
      this.#emitData(kind, payload);
    }
  }

  #emitData(kind, data) {
    if (!data) return;
    this.emit('data', { typ: 3, kind, data });
    this.emit(`data:${kind}`, data);
  }

  async #startPolling() {
    if (this.polling) return;
    this.polling = true;
    while (this.polling) {
      try {
        const [status, updates] = await this.request(OPCODES.POLL, this.cursor, 0);
        if (status === STATUS_SUCCESS) {
          this.#processPollUpdates(updates);
        }
      } catch (err) {
        this.emit('error', err);
        await new Promise((resolve) => setTimeout(resolve, this.pollIntervalMs));
      }
    }
  }

  #processPollUpdates(updates) {
    if (!Array.isArray(updates)) return;
    for (const entry of updates) {
      if (!Array.isArray(entry) || entry.length < 2) continue;
      const [opcode, items] = entry;
      const kind = UPDATE_KIND_BY_OPCODE[opcode] || 'unknown';
      if (!Array.isArray(items)) continue;
      for (const update of items) {
        if (!Array.isArray(update) || update.length < 2) continue;
        const [cursor, payload] = update;
        const nextCursor = Number(cursor);
        if (Number.isFinite(nextCursor) && nextCursor > this.cursor) {
          this.cursor = nextCursor;
        }
        this.#emitData(kind, this.#normalizePayload(payload));
      }
    }
  }

  #handleClose() {
    this.polling = false;
    this.rc4 = null;
    this.cursor = 0;
    if (this.heartbeatTimer) {
      clearInterval(this.heartbeatTimer);
      this.heartbeatTimer = null;
    }
    this.#rejectAllRequests('err_closed');
  }

  #buildEndpointUrl() {
    try {
      const url = new URL(this.endpoint);
      if (this.auth?.token) {
        url.searchParams.set('token', this.auth.token);
      }
      return url.toString();
    } catch {
      if (this.auth?.token && !this.endpoint.includes('token=')) {
        const joiner = this.endpoint.includes('?') ? '&' : '?';
        return `${this.endpoint}${joiner}token=${encodeURIComponent(this.auth.token)}`;
      }
      return this.endpoint;
    }
  }

  #handleDecodedMessage(message) {
    this.emit('raw', message);
    if (Array.isArray(message)) {
      const [reqId, status, payload] = message;
      this.#resolveRequest(reqId, status, payload);
      return;
    }

    if (!message || typeof message !== 'object') {
      if (message === 0 && !this.authenticated) {
        this.authenticated = true;
        this.emit('authenticated', { code: 0 });
        return;
      }
      this.emit('message', message);
      return;
    }

    if (typeof message.typ !== 'undefined') {
      switch (message.typ) {
        case 0:
          this.authenticated = true;
          this.emit('authenticated', message.data || {});
          if (this.subscriptions.length) {
            this.subscribe().catch((err) => this.emit('error', err));
          }
          this.startHeartbeat();
          break;
        case 1:
          this.emit('subscribed', message.data || {});
          break;
        case 2:
          this.emit('heartbeat', message.data || {});
          break;
        case 3:
          this.emit('data', message);
          if (message.kind) {
            this.emit(`data:${message.kind}`, message.data);
          }
          break;
        case 5:
          this.emit('errorMessage', message);
          break;
        default:
          this.emit('message', message);
      }
      return;
    }

    this.emit('message', message);
  }

  /**
   * åˆ†é…è´¦å·ç»™ç”¨æˆ·
   * @param {string} accountId - è´¦å·ID (uid)
   * @param {string} username - ç”¨æˆ·å (usr)
   * @param {string} password - å¯†ç  (pwd)
   * @param {object} options - å¯é€‰å‚æ•°
   * @param {string} options.email - é‚®ç®±
   * @param {string} options.remark - å¤‡æ³¨
   * @param {number} options.attr - å±æ€§ (é»˜è®¤: 1)
   * @param {number} options.share - åˆ†äº«æ ‡å¿— (é»˜è®¤: 0)
   * @param {number} timeout - è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
   * @returns {Promise<any>} - åˆ†é…ç»“æœ
   */
  async assignAccount(accountId, username, password, options = {}, timeout) {
    const payload = {
      uid: accountId,
      usr: username,
      pwd: password,
      attr: options.attr ?? 1,
      remark: options.remark ?? '',
      share: options.share ?? 0,
    };

    // å¦‚æœæä¾›äº† emailï¼Œæ·»åŠ åˆ° payload
    if (options.email) {
      payload.email = options.email;
    }

    return await this.#call(OPCODES.ASSIGN_ACCOUNT, payload, timeout);
  }
}
